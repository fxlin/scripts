#!/usr/bin/env python

""" 
parse the suspend/resume events from systrace html output (which is captured by atrace on Android). 
output suspend/resume epochs. 
monotonic clock rollback is treated.

Usage:
{prog} out.html
"""

import errno, optparse, os, select, subprocess, sys, time, zlib
import operator

keyword="machine_suspend[3]"
total = 0
all_procs = {}

'''
Assumption of the trace format: 

the interesting line will look like:
(some process info...) sched_switch: prev_comm=su prev_pid=6975 prev_prio=120 prev_state=S ==> next_comm=daemonsu next_pid=6978 next_prio=120
'''

once = True

begin_ts = 0
end_ts = 0
last_ts = 0
last_suspend = 0
last_resume = 0
last_resume_fix = -1  # resume, after clock rollback
should_include_line = True  # whether this line should be included in santinized output

if __name__ == '__main__':

  usage = "Usage: %prog [options] [input file]"
  desc = "Example: %prog -o output.html settings.html"
  
  parser = optparse.OptionParser(usage=usage, description=desc)
  parser.add_option('-o', dest='output_file', help='write HTML to FILE and discard clock rollback lines',
                    default='trace.html', metavar='FILE')
  options, args = parser.parse_args()
  
  fout = None
  if options.output_file is not None:
    fout = file(options.output_file, "w")
  
  f=file(args[0])
  
  lines=f.readlines()
  
  inheader = True
  nlines = len(lines)
  
  i = 0
  badlines=0
  
  while i < nlines:
    line = lines[i]
    
    # we are skipping the header
    if inheader:      
      if fout:  # preserve the header line in output (if any)
        fout.write(lines[i])
      if line.find("CPU") != -1 and line.find("TIMESTAMP") != -1 and line.find("FUNCTION") != -1:
        if fout: # write one extra header line
          fout.write(lines[i+1])
        inheader = False
        i += 2 
        print "		skipped header (%d lines)..." %(i)
      else:
        i += 1
      continue
    
    # we must be careful as comm (process name) may contain spaces
    # we are parsing the body 
    i += 1
    
    # first extract the time stamp
    t0=line.split(')')
    if len(t0) < 2:
      #print "bad line"
      #print t0
      badlines += 1
      if fout:  # we preserve these lines honestly (could be footer)
        fout.write(line)
      continue
    
    t1 = t0[1].split(':')
    if len(t1) < 2:
      print "bad line"
      print t1
      continue
          
    t2 = t1[0].split(' ')
    if len(t2) < 2:
      print "bad line"
      print t1
      continue    
    
    timestamp=t2[-1]
    ts = float(timestamp)
    
    if once:
      once = False
      begin_ts = ts
    else:
      if ts - last_ts < 0:    # clock rollback ends (after suspend ends recently)
        print "		[%d] clock roll back: at %.6f last_resume %.6f we lose %.6f" %(i, last_ts, last_resume, last_ts - last_resume)
        last_resume_fix = ts
        should_include_line = True

    last_ts = ts
    
    #print timestamp
    
    t = line.split(keyword)
    if len(t) <= 1:
      if fout and should_include_line:
        fout.write(line)
      continue
    elif t[1].find("begin") != -1:  # suspend begins
      should_include_line = False
      if last_resume_fix > 0:
        print "[%d]suspends. online for %.6f (%.6f -- %.6f)" %(i, ts - last_resume_fix, last_resume_fix, ts)
      else:
        print "[%d]suspends. online for ??? (??? -- %.6f)" %(i, ts)
      last_suspend = ts
    elif t[1].find("end") != -1:    # suspend ends
      print "[%d]resumes. offline for %.6f (%.6f -- %.6f)" %(i, ts - last_suspend, last_suspend, ts)
      last_resume = ts
    else:
      print "??? cannot understand line" + line
      
    if fout and should_include_line:
      fout.write(line)
        
  print "total: %.6f -- %.6f" %(begin_ts, ts)
  
  # put some marker -- 
  if fout:
    fout.write("---------------------\n");
    fout.write("xzl:\n");
    fout.write("generated by %s\n" %sys.argv[0]);
    fout.write("original file %s\n" %args[0]);
    fout.write("---------------------\n");
    

